%% Grammar and transformations

rules <- space? declaration_sequence space? code_block? space?
%{
  [_, Decls, _, Code0, _] = Node,
  Code = case Code0 of
             #code{} -> Code0;
             _ -> undefined
         end,
  #grammar{declarations = Decls,
           code = Code}
%};

declaration_sequence <- head:declaration tail:(space declaration)*
%{
  FirstRule = proplists:get_value(head, Node),
  OtherRules =  [I || [_,I] <- proplists:get_value(tail, Node, [])],
  [FirstRule|OtherRules]
%};

declaration <- nonterminal space* '<-' space* parsing_expression space? code_block? space? ';'
%{
  [NT, _, _, _, Expr, _, Code0|_] = Node,
  Code = case Code0 of
      #code{} -> Code0;
      _ -> undefined
  end,
  #declaration{ name = NT#nonterminal.name,
                expr = Expr,
                code = Code,
                index = Idx }
%};

parsing_expression <- choice / sequence / labeled_primary ~;

choice <- head:alternative tail:(space '/' space alternative)+
%{
  Tail = [lists:last(S) || S <- proplists:get_value(tail, Node)],
  Head = proplists:get_value(head, Node),
  #choice{alts = [Head|Tail],
          index = Idx}
%};

alternative <- sequence / labeled_primary ~;

labeled_primary <- label? primary
%{
  case Node of
      [[], Primary] -> Primary;
      [Label, Primary] ->
          #label{expr=Primary, label=Label, index=Idx}
  end
%};

label <- alpha_char alphanumeric_char* ':'
%{
  binary_to_atom(
    unicode:characters_to_binary(lists:sublist(Node, length(Node)-1)),
    utf8)
%};

primary <- prefix atomic / atomic suffix / atomic
%{
    case Node of
        [Atomic, plus] ->
            #plus{expr=Atomic, index=Idx};
        [Atomic, star] ->
            #star{expr=Atomic, index=Idx};
        [Atomic, optional] ->
            #optional{expr=Atomic, index=Idx};
        [assert, Atomic] ->
            #assert{expr=Atomic, index=Idx};
        [deny, Atomic] ->
            #deny{expr=Atomic, index=Idx};
        _ -> Node
    end
%};

sequence <- head:labeled_primary tail:(space labeled_primary)+
%{
  Tail = [lists:nth(2, S) || S <- proplists:get_value(tail, Node)],
  Head = proplists:get_value(head, Node),
  #sequence{exprs = [Head|Tail],
            index = Idx}
%};


suffix <- repetition_suffix / optional_suffix
%{
  case Node of
    <<"*">> -> star;
    <<"+">> -> plus;
    <<"?">> -> optional
  end
%};

optional_suffix <- '?' ~;

repetition_suffix <- '+' / '*' ~;

prefix <- '&' / '!'
%{
  case Node of
    <<"&">> -> assert;
    <<"!">> -> deny
  end
%};

atomic <- terminal / nonterminal / parenthesized_expression ~;

parenthesized_expression <- '(' space? parsing_expression space? ')' %{
   lists:nth(3, Node)
%};

nonterminal <- alpha_char alphanumeric_char*
%{
  Symbol = unicode:characters_to_binary(Node),
  #nonterminal{name = binary_to_atom(Symbol, utf8),
               index = Idx}
%};

terminal <- regexp_string / quoted_string / character_class / anything_symbol ~;

regexp_string <- '#' quoted_string
%{
  [_, #string{string = Regexp}] = Node,
  #regexp{regexp = Regexp, index = Idx}
%};

quoted_string <- single_quoted_string / double_quoted_string
%{
  String = proplists:get_value(string, Node),
  #string{string = unescape(unicode:characters_to_binary(String)),
          index = Idx}
%};

double_quoted_string <- '"' string:(!'"' ("\\\\" / '\\"' / .))* '"' ~;

single_quoted_string <- "'" string:(!"'" ("\\\\" / "\\'" / .))* "'" ~;

character_class <- '[' characters:(!']' ('\\\\' / '\\' . / . ))+ ']'
%{
  CharClass = proplists:get_value(characters, Node),
  #charclass{
     charclass = unescape(unicode:characters_to_binary(CharClass)),
     index = Idx
  }
%};

anything_symbol <- '.' %{
  #anything{index=Idx}
%};

alpha_char <- [A-Za-z_] ~;

alphanumeric_char <- alpha_char / [0-9] ~;

space <- (white / comment_to_eol)+ ~;

comment_to_eol <- !'%{' '%' (!"\n" .)* ~;

white <- [ \t\n\r] ~;

code_block <- ( '%{' code:('\\%' / '$%' / !'%}' .)+ '%}' ) /
              ('`' code:('\\`' / '$`' / !'`' .)+ '`') /
              '~'
%{
   case Node of
       <<"~">> -> #code{identity=true, index=Idx};
       %% Note I use c2l here instead of c2b so that we can use
       %% erl_scan and friends. Erlang code should probably be latin1
       %% for safety.
       _   -> #code{code=unicode:characters_to_list(proplists:get_value('code', Node)),
                    index=Idx}
   end
%};

%% Extra functions

%{
-include("neotoma.hrl").

-define(SPECIAL_CHARS,
        [{$b, $\b}, {$d, $\d}, {$e, $\e},
         {$f, $\f}, {$n, $\n}, {$r, $\r},
         {$s, $\s}, {$t, $\t}, {$v, $\v}]).

unescape(<<>>) -> <<>>;
unescape(<<$\\, C, T/binary>>)
  when C == $b; C == $d; C == $e; C == $f;
       C == $n; C == $r; C == $s; C == $t;
       C == $v ->
    UC = proplists:get_value(C, ?SPECIAL_CHARS),
    <<UC, (unescape(T))/binary>>;
unescape(<<$\\, C/utf8, T/binary>>) ->
    <<C/utf8, (unescape(T))/binary>>;
unescape(<<C/utf8, T/binary>>) ->
    <<C/utf8, (unescape(T))/binary>>.
%}
